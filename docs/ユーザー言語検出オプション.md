# ユーザー言語特定・表示システム 実装オプション

**作成日**: 2025-11-21
**目的**: ユーザーごとに最適な言語で全コンテンツを表示するシステムの設計

---

## 前提条件

- 対応言語: 日本語(ja)、英語(en)、中国語簡体字(zh-CN)、中国語繁体字(zh-TW)、韓国語(ko)
- 認証済みユーザーと非認証ユーザーの両方に対応
- Next.js App Router使用
- Supabase認証使用

---

## オプション比較表

| オプション | 初回検出精度 | 実装複雑度 | パフォーマンス | SEO対応 | 推奨度 |
|-----------|------------|----------|------------|---------|-------|
| **A: URLパス方式** | 中 | 低 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **B: Cookie/セッション方式** | 高 | 中 | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ |
| **C: DB保存+Cookie併用** | 高 | 高 | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **D: サブドメイン方式** | 中 | 高 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |

---

## オプションA: URLパス方式（推奨）

### 概要
Next.jsのi18nルーティングを使用し、URLに言語を含める方式

```
https://pokepoke.app/ja/decks
https://pokepoke.app/en/decks
https://pokepoke.app/ko/decks
```

### 実装方法

#### 1. ディレクトリ構造
```
app/
  [locale]/
    layout.tsx        # 言語別レイアウト
    page.tsx          # トップページ
    decks/
      page.tsx        # デッキ一覧
      [id]/
        page.tsx      # デッキ詳細
    info/
      page.tsx
```

#### 2. Middleware実装
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import Negotiator from 'negotiator';
import { match } from '@formatjs/intl-localematcher';

const locales = ['ja', 'en', 'zh-CN', 'zh-TW', 'ko'];
const defaultLocale = 'ja';

function getLocale(request: NextRequest): string {
  // 1. URLからロケールを取得（既に選択済みの場合）
  const pathname = request.nextUrl.pathname;
  const pathnameLocale = locales.find(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );
  if (pathnameLocale) return pathnameLocale;

  // 2. Cookieから取得（前回の選択を優先）
  const localeCookie = request.cookies.get('NEXT_LOCALE')?.value;
  if (localeCookie && locales.includes(localeCookie)) {
    return localeCookie;
  }

  // 3. Vercel Geo情報から推測
  const country = request.geo?.country;
  const geoLocale = getLocaleFromCountry(country);
  if (geoLocale) return geoLocale;

  // 4. Accept-Languageヘッダーから取得
  const negotiatorHeaders: Record<string, string> = {};
  request.headers.forEach((value, key) => (negotiatorHeaders[key] = value));

  const languages = new Negotiator({ headers: negotiatorHeaders }).languages();
  const locale = match(languages, locales, defaultLocale);

  return locale;
}

function getLocaleFromCountry(country?: string): string | null {
  const countryLocaleMap: Record<string, string> = {
    'JP': 'ja',
    'US': 'en',
    'GB': 'en',
    'CN': 'zh-CN',
    'TW': 'zh-TW',
    'HK': 'zh-TW',
    'KR': 'ko',
  };
  return country ? countryLocaleMap[country] || null : null;
}

export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname;

  // 静的ファイルとAPIルートは除外
  if (
    pathname.startsWith('/_next') ||
    pathname.startsWith('/api') ||
    pathname.startsWith('/static') ||
    pathname.match(/\.(ico|png|jpg|jpeg|svg|css|js)$/)
  ) {
    return NextResponse.next();
  }

  // パスに言語が含まれているかチェック
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );

  if (pathnameHasLocale) {
    // 既に言語パスがある場合はそのまま
    return NextResponse.next();
  }

  // 言語を検出してリダイレクト
  const locale = getLocale(request);
  const newUrl = new URL(`/${locale}${pathname}`, request.url);

  const response = NextResponse.redirect(newUrl);
  response.cookies.set('NEXT_LOCALE', locale, {
    maxAge: 60 * 60 * 24 * 365, // 1年
    path: '/',
  });

  return response;
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|.*\\..*|).*)',
  ],
};
```

#### 3. レイアウトでの言語設定
```typescript
// app/[locale]/layout.tsx
import { notFound } from 'next/navigation';

const locales = ['ja', 'en', 'zh-CN', 'zh-TW', 'ko'];

export async function generateStaticParams() {
  return locales.map((locale) => ({ locale }));
}

export default async function LocaleLayout({
  children,
  params: { locale },
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  if (!locales.includes(locale)) {
    notFound();
  }

  return (
    <html lang={locale}>
      <body>
        <LanguageSwitcher currentLocale={locale} />
        {children}
      </body>
    </html>
  );
}
```

#### 4. データベーススキーマ（言語設定保存）

**現在のusersテーブル**:
```sql
CREATE TABLE public.users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    name TEXT,
    email TEXT,
    avatar_url TEXT,
    is_admin BOOLEAN NOT NULL DEFAULT FALSE,
    display_name TEXT,
    pokepoke_id TEXT UNIQUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

**言語設定カラムを追加**:
```sql
-- Step 1: 言語設定カラムを追加
ALTER TABLE public.users
ADD COLUMN preferred_language TEXT DEFAULT 'ja',
ADD COLUMN detected_languages JSONB DEFAULT '[]'::jsonb,
ADD COLUMN language_detection_info JSONB DEFAULT '{}'::jsonb,
ADD COLUMN language_manually_set BOOLEAN DEFAULT FALSE,
ADD COLUMN language_updated_at TIMESTAMPTZ;

-- Step 2: チェック制約
ALTER TABLE public.users
ADD CONSTRAINT check_preferred_language
CHECK (preferred_language IN ('ja', 'en', 'zh-CN', 'zh-TW', 'ko'));

-- Step 3: インデックス
CREATE INDEX idx_users_preferred_language ON public.users(preferred_language);
CREATE INDEX idx_users_language_manually_set ON public.users(language_manually_set);

-- Step 4: コメント
COMMENT ON COLUMN public.users.preferred_language IS 'ユーザーの優先言語設定';
COMMENT ON COLUMN public.users.detected_languages IS '過去に検出された言語の履歴: [{"locale": "ja", "source": "geo", "timestamp": "..."}]';
COMMENT ON COLUMN public.users.language_detection_info IS '最新の検出情報: {"country": "JP", "browser_lang": "ja,en", "detected_at": "..."}';
COMMENT ON COLUMN public.users.language_manually_set IS 'ユーザーが手動で言語を設定したかどうか';
```

### メリット ✅
- **SEO最強**: 各言語でクロール可能、検索結果に適切な言語で表示
- **共有しやすい**: URLに言語が含まれるため、共有時に意図した言語で表示
- **実装がシンプル**: Next.jsの標準機能で対応可能
- **パフォーマンス良好**: 静的生成可能
- **ブラウザの戻る/進むが自然**: 言語切り替え履歴が残る

### デメリット ⚠️
- URLが少し長くなる
- 言語切り替え時にページ遷移（リロード）が発生

### 推奨ユースケース
- **公開コンテンツが多い**: デッキガイド、記事など
- **SEOが重要**: Google検索からの流入を重視
- **コンテンツ共有が多い**: SNSでのシェア

---

## オプションB: Cookie/セッション方式

### 概要
URLは変えず、CookieとAccept-Languageで言語を判定

```
https://pokepoke.app/decks （全言語共通URL）
```

### 実装方法

#### 1. Middleware実装
```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server';

export function middleware(request: NextRequest) {
  const locale = detectLocale(request); // 同様のロジック

  const response = NextResponse.next();
  response.headers.set('x-user-locale', locale);
  response.cookies.set('NEXT_LOCALE', locale, {
    maxAge: 60 * 60 * 24 * 365,
    path: '/',
  });

  return response;
}
```

#### 2. サーバーコンポーネントで言語取得
```typescript
// app/decks/page.tsx
import { cookies, headers } from 'next/headers';

export default async function DecksPage() {
  const locale = cookies().get('NEXT_LOCALE')?.value ||
                 headers().get('x-user-locale') || 'ja';

  const decks = await getLocalizedDecks(locale);

  return <DeckList decks={decks} locale={locale} />;
}
```

#### 3. API実装
```typescript
// app/api/decks/route.ts
export async function GET(request: Request) {
  const locale = request.headers.get('accept-language') || 'ja';
  // 言語に応じたデータ取得
}
```

### メリット ✅
- **URLがクリーン**: 言語パスが不要
- **動的切り替え**: リロード不要で言語変更可能（クライアント側実装で）
- **実装が直感的**: 既存のルーティングを変更不要

### デメリット ⚠️
- **SEO困難**: 同一URLに複数言語が混在、Googleが混乱
- **共有時の問題**: URLだけでは言語が特定できない
- **キャッシュ問題**: CDNでのキャッシュが複雑化

### 推奨ユースケース
- **会員制サービス**: 非公開コンテンツメイン
- **SEO不要**: アプリケーション的な性質

---

## オプションC: DB保存+Cookie併用（最推奨）

### 概要
**オプションAとDBを組み合わせた最強の方式**

- 認証済みユーザー: DBに言語設定を保存、Cookie+URLで表示
- 非認証ユーザー: Cookie+URLで判定

### 実装方法

#### 1. データベーススキーマ拡張
```sql
-- ユーザープロファイルに言語設定追加
ALTER TABLE public.users
ADD COLUMN preferred_language TEXT DEFAULT 'ja',
ADD COLUMN detected_languages JSONB DEFAULT '[]'::jsonb, -- 検出履歴
ADD COLUMN language_detection_info JSONB DEFAULT '{}'::jsonb, -- 検出メタデータ
ADD COLUMN language_manually_set BOOLEAN DEFAULT false, -- 手動設定フラグ
ADD COLUMN language_updated_at TIMESTAMPTZ;

-- チェック制約
ALTER TABLE public.users
ADD CONSTRAINT check_preferred_language
CHECK (preferred_language IN ('ja', 'en', 'zh-CN', 'zh-TW', 'ko'));

COMMENT ON COLUMN public.users.detected_languages IS
  '過去に検出された言語の履歴: [{"locale": "ja", "source": "geo", "timestamp": "..."}]';
COMMENT ON COLUMN public.users.language_detection_info IS
  '検出時の情報: {"country": "JP", "browser_lang": "ja,en", "ip": "..."}';
```

#### 2. 高度なMiddleware
```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';

export async function middleware(request: NextRequest) {
  const response = NextResponse.next();
  const supabase = createMiddlewareClient({ req: request, res: response });

  // 1. 認証状態チェック
  const { data: { session } } = await supabase.auth.getSession();

  let locale: string;

  if (session) {
    // 認証済みユーザー: DBから言語設定を取得
    const { data: user } = await supabase
      .from('users')
      .select('preferred_language, language_manually_set')
      .eq('id', session.user.id)
      .single();

    if (user?.preferred_language) {
      locale = user.preferred_language;

      // 手動設定されていない場合は、より正確な言語に更新する機会を提供
      if (!user.language_manually_set) {
        const detectedLocale = detectLocaleFromRequest(request);
        if (detectedLocale !== locale) {
          // バックグラウンドで候補を記録
          await recordLanguageCandidate(session.user.id, detectedLocale);
        }
      }
    } else {
      // 初回: 検出して保存
      locale = detectLocaleFromRequest(request);
      await saveUserLanguage(session.user.id, locale, false);
    }
  } else {
    // 非認証ユーザー: Cookie + 検出
    locale = detectLocaleFromRequest(request);
  }

  // URLリダイレクト処理（オプションAと同様）
  const pathname = request.nextUrl.pathname;
  const pathnameHasLocale = locales.some(
    (loc) => pathname.startsWith(`/${loc}/`) || pathname === `/${loc}`
  );

  if (!pathnameHasLocale) {
    const newUrl = new URL(`/${locale}${pathname}`, request.url);
    const redirectResponse = NextResponse.redirect(newUrl);
    redirectResponse.cookies.set('NEXT_LOCALE', locale, {
      maxAge: 60 * 60 * 24 * 365,
      path: '/',
    });
    return redirectResponse;
  }

  return response;
}

async function saveUserLanguage(
  userId: string,
  locale: string,
  manuallySet: boolean
) {
  const supabase = createServerClient(); // サーバー側クライアント

  await supabase
    .from('users')
    .update({
      preferred_language: locale,
      language_manually_set: manuallySet,
      language_updated_at: new Date().toISOString(),
    })
    .eq('id', userId);
}

async function recordLanguageCandidate(userId: string, candidateLocale: string) {
  // 言語候補を記録（後でユーザーに提案できる）
  const supabase = createServerClient();

  await supabase
    .from('users')
    .update({
      detected_languages: supabase.raw(`
        detected_languages ||
        jsonb_build_object(
          'locale', '${candidateLocale}',
          'detected_at', now()
        )::jsonb
      `),
    })
    .eq('id', userId);
}
```

#### 3. 言語切り替えAPI
```typescript
// app/api/user/language/route.ts
export async function POST(request: Request) {
  const { locale } = await request.json();
  const supabase = createRouteHandlerClient({ cookies });

  const { data: { session } } = await supabase.auth.getSession();
  if (!session) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 });
  }

  await supabase
    .from('users')
    .update({
      preferred_language: locale,
      language_manually_set: true, // 手動設定フラグを立てる
      language_updated_at: new Date().toISOString(),
    })
    .eq('id', session.user.id);

  return Response.json({ success: true });
}
```

#### 4. 言語切り替えコンポーネント
```typescript
// components/LanguageSwitcher.tsx
'use client';

import { useRouter, usePathname } from 'next/navigation';
import { useState } from 'react';

const languages = [
  { code: 'ja', name: '日本語', flag: '🇯🇵' },
  { code: 'en', name: 'English', flag: '🇺🇸' },
  { code: 'zh-CN', name: '简体中文', flag: '🇨🇳' },
  { code: 'zh-TW', name: '繁體中文', flag: '🇹🇼' },
  { code: 'ko', name: '한국어', flag: '🇰🇷' },
];

export function LanguageSwitcher({ currentLocale, isAuthenticated }: Props) {
  const router = useRouter();
  const pathname = usePathname();
  const [isChanging, setIsChanging] = useState(false);

  const changeLanguage = async (newLocale: string) => {
    setIsChanging(true);

    // 認証済みユーザーの場合はDBに保存
    if (isAuthenticated) {
      await fetch('/api/user/language', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ locale: newLocale }),
      });
    }

    // URLを変更（言語パスを置き換え）
    const newPathname = pathname.replace(`/${currentLocale}`, `/${newLocale}`);
    router.push(newPathname);
    router.refresh();
  };

  return (
    <select
      value={currentLocale}
      onChange={(e) => changeLanguage(e.target.value)}
      disabled={isChanging}
    >
      {languages.map((lang) => (
        <option key={lang.code} value={lang.code}>
          {lang.flag} {lang.name}
        </option>
      ))}
    </select>
  );
}
```

### メリット ✅
- **最高のUX**: 認証ユーザーはどのデバイスでも同じ言語
- **正確な設定**: ユーザーの明示的な選択を尊重
- **分析可能**: 言語の使用統計を取得できる
- **SEO対応**: URLベース（オプションA）の利点を継承
- **段階的最適化**: 使用するほど精度が向上

### デメリット ⚠️
- **実装が複雑**: DB、Cookie、URL、Middlewareの連携
- **Middlewareのパフォーマンス**: DB問い合わせが入る（キャッシュ必須）

### 推奨ユースケース
- **本格的なサービス**: ログインユーザーがメイン
- **マルチデバイス対応**: スマホ・PCで同じ言語設定
- **長期運用**: データ分析で改善していく

---

## オプションD: サブドメイン方式

### 概要
言語ごとにサブドメインを分ける

```
https://ja.pokepoke.app
https://en.pokepoke.app
https://ko.pokepoke.app
```

### メリット ✅
- **完全な分離**: 言語ごとに独立したデプロイ可能
- **SEO**: 言語が明確

### デメリット ⚠️
- **SSL証明書の管理**: サブドメインごと
- **インフラコスト**: 複数のデプロイ環境
- **実装の複雑さ**: 認証の共有など

### 推奨ユースケース
- **大規模サービス**: 各言語で独立した運用体制
- **完全なローカライズ**: 言語ごとに機能差分がある

---

## 推奨アプローチ

### 🥇 第1推奨: オプションC（DB保存+URL併用）

**理由**:
1. ユーザー体験が最高（認証ユーザーは自動的に好みの言語）
2. SEO対策も万全（URL方式の利点）
3. データ分析が可能（言語使用統計）
4. 段階的な改善が可能

**実装順序**:
1. まずオプションA（URLベース）を実装
2. ユーザーテーブルに言語カラム追加
3. Middlewareで認証チェック追加
4. 言語設定API実装

### 🥈 第2推奨: オプションA（URLパス方式）

**理由**:
- シンプルで確実
- SEO効果が高い
- 後からオプションCに移行可能

### 実装フェーズ案

#### Phase 1: 基本実装（2週間）
- [ ] オプションAのMiddleware実装
- [ ] `[locale]`ディレクトリ構造構築
- [ ] 言語切り替えUI実装

#### Phase 2: ユーザー言語設定（1週間）
- [ ] usersテーブルに言語カラム追加
- [ ] 言語設定API実装
- [ ] Middleware強化（認証ユーザー対応）

#### Phase 3: 最適化（1週間）
- [ ] 言語検出精度向上
- [ ] パフォーマンス最適化（キャッシュ等）
- [ ] 分析ダッシュボード

---

## 質問と選択肢

以下の質問にお答えください：

### Q1: URLに言語パスを含めることについて
- [ ] **A**: 含める（`/ja/decks`）- SEO重視
- [ ] **B**: 含めない（`/decks`）- URLクリーン重視

### Q2: 認証ユーザーの言語設定保存について
- [ ] **A**: DBに保存する - デバイス間で統一
- [ ] **B**: Cookieのみ - シンプル
- [ ] **C**: 両方使う - 最適なUX

### Q3: 非認証ユーザーの初回言語検出方法
- [ ] **A**: 自動検出のみ（Geo + Accept-Language）
- [ ] **B**: 自動検出 + 確認モーダル表示
- [ ] **C**: 必ず言語選択モーダル表示

### Q4: 言語切り替え後の挙動
- [ ] **A**: ページリロード（URLベースなら自然）
- [ ] **B**: リロードなし（SPA的な動作）

### Q5: 実装優先度
- [ ] **A**: まずシンプルに（オプションA）→ 後で拡張
- [ ] **B**: 最初から完璧に（オプションC）

---

## 次のステップ

1. 上記の質問にご回答いただく
2. 選択したオプションの詳細設計
3. マイグレーションスクリプト作成
4. 実装開始

ご質問やご不明な点があればお気軽にお尋ねください！
