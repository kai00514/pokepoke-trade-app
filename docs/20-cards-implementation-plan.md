# /decks の 20枚カード横スクロール表示 実装計画（コーディング不要版）

目的
- 各デッキ行に「20枚のカード」を必ず横スクロールで表示する。
- サムネイルのフォールバックは使わない（＝選択20枚のセットを表示ソースにする）。
- 並び順はユーザーが選んだ順序を尊重。
- ローディングやエラー時も UX を崩さず 20枠を確保。

スコープ（今回の集中ポイント）
- 「20枚のカード画像が表示される横スクロール部分」のみ。
- タイトル、更新日、ハート/お気に入り/コメント等のアクションはスコープ外（既存のまま）。

---

データ契約（前提）
1) Deck（フロント側で使用）
- id: string
- selected_card_ids: number[20]
  - デッキごとに「見せたい 20 枚のカード ID」を保持。必ず 20 件、順序保証。
  - これが本表示の唯一のソース。
- その他（likes/favorites/comments 等）は既存どおり。

2) Card（getCardsByIds の戻り値）
- id: number
- name: string
- thumb_url: string（表示はサムネイル中心）
- image_url?: string（任意）

バックエンド/API の前提
- getDecksList / getDeckPagesList は各デッキについて selected_card_ids（20 件）を返す。
- 既存デッキで未設定の場合は、バックフィルで 20 件を生成して保存（詳細は「バックフィル」参照）。

---

表示ロジック（アルゴリズム）
A. 1ページ分を読み込む際の前処理（バッチ取得）
- Step A-1: 表示対象の全デッキからカード ID を一括抽出
  - `allIds = unique(decks.flatMap(d => d.selected_card_ids))`
- Step A-2: `getCardsByIds(allIds)` を1回呼ぶ（バッチ化）
  - 戻り値を `Map<number, Card>` に変換してメモリキャッシュ（ページ間での再利用も可）
- Step A-3: ローディング状態中は各デッキで「20個のスケルトン」を表示

B. 各デッキ行での 20 枚の決定と描画
- Step B-1: `ids = deck.selected_card_ids`（20件・順序保証）
- Step B-2: `cards = ids.map(id => CardMap.get(id))`
- Step B-3: いずれかの ID の解決に失敗した場合でも「枠」は保持
  - 具体的には `CardMap.get(id)` が未定義なら、その位置に「プレースホルダー画像」を表示（落ちた部分のみ代替）
  - こうして「20枠は必ず埋まる」を担保
- Step B-4: 各カードは固定タイルに収める
  - 固定幅（例: 96px）・アスペクト比 (5/7)
  - 画像は `object-contain` 的なフィットで切れを防止
- Step B-5: 横スクロールコンテナ
  - overflow-x: auto、スクロールスナップ（任意）
  - スクロールバーは視覚的に非表示（OS依存）だが、キーボード/ポインタ操作は可能に保つ
  - aria-label を付けてアクセシビリティ配慮

C. ローディング/エラー時の UX
- ローディング中：各デッキ行に「20個のスケルトンタイル」を並べる
- 部分エラー：CardMapに存在しない ID の位置だけ「プレースホルダー画像」
- 全体エラー：ページレベルのトーストやリトライを既存に合わせて表示（本スコープ外）

---

バックフィル（既存データの selected_card_ids 生成）
- 現行データに `selected_card_ids` が無い場合の移行案（サーバー側で一括実行）
  1) deck.deck_cards を保存順で展開（quantity 分だけ並べる）
  2) 20件に満たない場合は、展開済み配列を先頭から循環して 20件まで追加（完全に空のデッキは保存時に弾く運用）
  3) 20件を超える場合は先頭から 20件で打ち切り
  4) 生成結果を `selected_card_ids` として保存
- deck_pages（tier/featured/newpack）も `curated_card_ids` を `selected_card_ids` として付与
  - これにより、どのカテゴリでも 20 枚が確実に表示できる

---

パフォーマンス戦略
- バッチ取得：1ページで1回の `getCardsByIds` に集約
- 重複排除：ID は `Set` でユニーク化して最小限の取得に
- キャッシュ：`Map<number, Card>` をメモリキャッシュ（ページ内共有）。必要に応じて LRU
- 遅延評価：多数行がある場合は IntersectionObserver で「ビューポート内の行」だけカード解決（任意）
- 画像最適化：表示幅に合わせたサムネイルを使用（thumb_url 前提）

---

アクセシビリティ
- 横スクロール領域に `aria-label` を付与
- タイルは装飾扱い（img alt にカード名）。詳細導線は別途（タイトルや「詳細を見る」リンク）
- キーボード操作配慮（左右キーでスクロール補助などは任意）

---

受け入れ基準（Acceptance Criteria）
- すべてのデッキ行で常に「20枚」のタイルが表示される
- 並び順は `selected_card_ids` に厳密一致
- ローディング中は 20 個のスケルトンが表示される
- 取得失敗の ID が含まれても 20 枠は維持され、当該位置のみプレースホルダーになる
- サムネイルのフォールバック（サムネ1枚で埋める）は一切使用しない

---

実装手順（今回の 20 枚表示に必要な最小工程）
1) API・データ
   - getDecksList/getDeckPagesList が `selected_card_ids: number[20]` を返すことを確認（なければバックフィルを先行）
   - getCardsByIds(ids: number[]) をページ単位で一括呼び出し可能に

2) ページ側の前処理
   - 一覧取得後、ページ内すべての `selected_card_ids` をユニーク化して `getCardsByIds` を1回だけ実行
   - 結果を `Map<number, Card>` に格納

3) 各デッキ行のレンダリング
   - `ids = deck.selected_card_ids`
   - `ids.map(id => CardMap.get(id) ?? placeholder)` で20件をそのまま横並び
   - スクロールコンテナに overflow-x: auto と固定タイル幅でレイアウト

4) QA
   - deck_pages 含む全カテゴリで 20 枚表示を確認
   - 回線遅延時、スケルトン → 20 枚へ置き換わることを確認
   - 取得失敗 ID の位置だけがプレースホルダーになることを確認

---

補足（段階導入）
- 段階1（今回）：`selected_card_ids` を前提に、20枚横スクロールの UI を確立（本ドキュメントの範囲）
- 段階2：バックフィルを実施して全デッキに `selected_card_ids` を行き渡らせる
- 段階3：編集UI（ユーザーが 20 枚を選ぶ）を導入して順序とセットの管理をユーザーに委ねる（任意）
